# def bubble_sort(lst, desc=False):
#     new_lst = [] #Создаю навый список вне цикла, буду складывать туда нужные мне значения 
#     if desc == False: # проверка необязательного параметра
#         while len(lst) > 0: # Начинаю цикл, пока длина входящего списка бьольше нуля то
#             new_lst.append(min(lst)) #нахожу во входном списке МИНИМАЛЬНОЕ значение и добавляю его в новый список new_list, после чего -  
#             lst.remove(min(lst))  # удаляю этот элемент, длина списка становиться n - 1 и цикл запускается заново 
#     elif desc == True: # здесь все то же самое, только ищем наибольший элемент во входящем списке
#          while len(lst) > 0:
#             new_lst.append(max(lst))
#             lst.remove(max(lst))
#     return new_lst



def bubble_sort(lst, desc=False):
    i = 1
    while i <= len(lst): #Перебираем циклом индексы списка 
        i += 1 #после каждого прохода увеличиваем счетчик на 1
        for j in range(len(lst) - 1):           #Когда внешний цикл проходит по индексу мы проверяем значение индекса ,  
            if not desc:                         #то есть на определенном индексе i мы смотрим определенный элемент J и J + 1
                if lst[j] > lst[j+1]:  # - сравниваем их , 
                    lst[j], lst[j+1] = lst[j+1], lst[j] # вот это я подсмотрел в интернете, не знал что так можно делать 
            elif desc:
                if lst[j] < lst[j+1]:
                    lst[j], lst[j+1] = lst[j+1], lst[j]
    return lst
